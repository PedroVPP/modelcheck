/* Generated By:JavaCC: Do not edit this line. ssc5906JMC.java */
package br.parser;



import br.mef.*;
import java.util.*;
import javax.swing.*;

public class ssc5906JMC implements ssc5906JMCConstants {

static private final String Version = ("ssc5906JMC - icmcJMC - Java Model Checker \u005c"Version 0.1\u005c"  \u005cn A Java implementation");
//static private MEF mef;
static private String ctlExpression = "";
private ArrayList<Expression> expressions = new ArrayList<Expression>();

  public static void main(String args []) throws ParseException
  {
        System.out.println(Version);
        String filename = " "; // file name to analyse
        ssc5906JMC parser;

        //Declaracao da MEF a ser instaciada e povoado por estados e propriedades




        if (args.length < 1)
        System.out.println("Sorry, you have to insert a parameter ...");
        // caso em que nenhum arquivo é passado como parâmetro

        else
        {
        //abrir o arquivo para leitura
        filename = args[args.length-1];
    System.out.println("Reading Specification from file " + filename + " . . .");
        try {  // cria AS
            parser = new ssc5906JMC(new java.io.FileInputStream(filename));
                        parser.unitJavaMC(); // chamada do método que faz a análise ...
            System.out.println("--  Arquivo de parser valido --");

                        if (parser.token_source.foundLexError() > 0)
                {
              System.out.println("Lexical Errors found");
                }
                else
                {
                        /* aqui devemos chamar métodos para processar a MEF e verificar propriedades ...*/
                        System.out.println("#################Analise da MEF definida#################");
                        ArrayList<State> state  = MEF.getInstance().getStates();

                                        /*Analise quanto a estados */
                        System.out.println("O MEF definida contem: "+state.size()+" estados");
                        System.out.println("O estado inicial eh "+MEF.getInstance().getFirstState().getName());
                        System.out.println("\u005cn ####    os estados declarados  e transicoes sao  ######\u005cn");


                        ArrayList<State>  stateChildrem = null;
                        for (State s : state) {

                          System.out.print("estado -"+s.getName()+"- e transicoes para [");
                          stateChildrem = s.getChildren();

                          for (State s2 : stateChildrem) {
                          System.out.print(" "+s2.getName()+" ");
                          }
                        System.out.print("]\u005cn\u005cn");
                        }


                        /*Analise quanto a propriedades */
                        ArrayList<Property> properties = MEF.getInstance().getProperties();
                        System.out.println("O MEF definida contem: "+properties.size()+" propriedades");

                        System.out.println(" ---  "+ state.size());
                        System.out.println("\u005cn ####    as propriedades declaradas sao  ######\u005cn");

                        for (Property p : properties) {
                          System.out.println(" "+p.getName()+" ");
                                }

                        System.out.println("\u005cn ####    os estados e suas propriedades sao  ######\u005cn");

                        ArrayList<Property> validProperties =  null;
                        for (State s : state) {
                        validProperties = s.getValidProperties();
                        System.out.print("-para o estado "+s.getName()+" as propriedades validas  sao [" );

                        for (Property pState : validProperties) {
                                System.out.print(" "+pState.getName()+" ");
                           }
                        System.out.print(" ] \u005cn\u005cn");

                        }

                        //dps das analises, criacao da MEF
                        //MEF.getInstance().createMEF();

                        //System.out.println("#################Analise das Expressões CTL#################");
                        //Expression e = (Expression) MEF.getInstance().getExpressions().get(MEF.getInstance().getExpressions().size() -1);
                        //considerar apenas o último elemento de expressions da MEF,
                        //os anteriores foram utilizados apenas para auxilar a construção
                        // e não serão mais utilizados (poderia inclusive ser apagados depois...  			
                        //printExpressions(e);
                        }
        }
    catch (java.io.FileNotFoundException e)
        {
        System.out.println("File " + filename + " not found.");
        return;
        }
        }
          } // end main()

/*
static public void printExpressions(Expression e)
{
  	  if (!e.getType().equals("CS")) //Operações AX AF EX EG EF ...  	  {
  	    System.out.println(e.getName());  	  }	  
	  if (e.getExp1() != null)	  {		printExpressions(e.getExp1());
	  }
	    
	  if (e.getExp2() != null)
	  {
		printExpressions(e.getExp2());
	  }
		  
}
*/
static public String im(String s)
{
int k;
   k = s.lastIndexOf("\u005c"");
   try {s = s.substring(1,k);}
   catch (StringIndexOutOfBoundsException e)
   {}
   return s;
}

//########################################
// INICIO DA DECLARACAO DE DO AN. LEXICO
//########################################
  final public void unitJavaMC() throws ParseException {
    trace_call("unitJavaMC");
    try {
      jj_consume_token(JMC);
      icmcJavaModelCheckerUnit();
      jj_consume_token(JMC);
    } finally {
      trace_return("unitJavaMC");
    }
  }

  final public void icmcJavaModelCheckerUnit() throws ParseException {
    trace_call("icmcJavaModelCheckerUnit");
    try {
      modelDec();
      ctlGrammar();
           Expression expMEF = expressions.get(expressions.size() -1);
           expMEF.setName(ctlExpression);
           MEF.getInstance().getExpressions().add(expMEF);
           ctlExpression = "";
      label_1:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case COMMA:
          ;
          break;
        default:
          jj_la1[0] = jj_gen;
          break label_1;
        }
        jj_consume_token(COMMA);
        ctlGrammar();
           expMEF = expressions.get(expressions.size() -1);
           expMEF.setName(ctlExpression);
           MEF.getInstance().getExpressions().add(expMEF);
           ctlExpression = "";
      }
    } finally {
      trace_return("icmcJavaModelCheckerUnit");
    }
  }

  final public void modelDec() throws ParseException {
    trace_call("modelDec");
    try {
      satesDec();
      propertiesDec();
      behavioerDec();
    } finally {
      trace_return("modelDec");
    }
  }

  final public Expression ctlGrammar() throws ParseException {
    trace_call("ctlGrammar");
    try {
  Token t = new Token();
  Expression exp = null;
  Expression exp1 = null;
  Expression exp2 = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case TRUE:
      case FALSE:
      case IDENTIFIER:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          t = jj_consume_token(IDENTIFIER);
          break;
        case TRUE:
          //identificador
          
                    t = jj_consume_token(TRUE);
          break;
        case FALSE:
          // definicao de tautologia
          
                    t = jj_consume_token(FALSE);
          break;
        default:
          jj_la1[1] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
            System.out.println("Verifica\u00e7\u00e3o da Validade da Propriedade  "+t.toString());
                if (MEF.getInstance().getProperty(t.toString()).equals(null))
                {
                javax.swing.JOptionPane.showMessageDialog(null, "A propriedade "+t.toString()+" nao foi declarada", "MEF - Expression Error ", JOptionPane.INFORMATION_MESSAGE);

                //  System.out.println();

                }

            exp = new Expression(t.toString());
            exp.setType(null);
            ctlExpression = ctlExpression + t.toString();
        break;
      case Lparentheses:
        jj_consume_token(Lparentheses);
        exp = logicalRelations();
        jj_consume_token(Rparentheses);
        break;
      case AX:
      case EX:
      case AF:
      case EF:
      case AG:
      case EG:
        //definicao de relacoes logicas parentisadas em CTL
          exp = ctlSpecifications();
        exp1 = ctlGrammar();
        break;
      case E:
      case A:
        //exp1 = unionDec() exp2 = union()
          exp = unionAux();
        break;
      default:
        jj_la1[2] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    if (exp1 != null)
    {
                exp.setExp1(exp1);

    }
    this.expressions.add(exp);
    {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ctlGrammar");
    }
  }

  final public Expression logicalRelations() throws ParseException {
    trace_call("logicalRelations");
    try {
  Expression exp;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case NOT:
        exp = negation();
        break;
      case E:
      case A:
      case AX:
      case EX:
      case AF:
      case EF:
      case AG:
      case EG:
      case TRUE:
      case FALSE:
      case Lparentheses:
      case IDENTIFIER:
        exp = dualRelations();
        break;
      default:
        jj_la1[3] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("logicalRelations");
    }
  }

  final public Expression negation() throws ParseException {
    trace_call("negation");
    try {
   Token t = new Token();
   Expression exp;
   Expression exp1;
      t = jj_consume_token(NOT);
      ctlExpression = ctlExpression + " ( ~ ";
      exp1 = ctlGrammar();
      exp = new Expression(t.toString() + " "+exp1.getName());
      exp.setExp1(exp1);
      exp.setType(ExpressionType.NOT);
      ctlExpression = ctlExpression + " ) ";
      {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("negation");
    }
  }

  final public Expression dualRelations() throws ParseException {
    trace_call("dualRelations");
    try {
  Token t = new Token();
  Expression exp;
  Expression exp1;
  Expression exp2;
  ExpressionType ep = null;
  ctlExpression = ctlExpression + " ( ";
      exp1 = ctlGrammar();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AND:
        t = jj_consume_token(AND);
        break;
      case OR:
        //conjunction
                 t = jj_consume_token(OR);
        break;
      case IMPLICATION:
        //disjunction
                 t = jj_consume_token(IMPLICATION);
        break;
      case BICONDICIONAL:
        //material implication - if  .. then
                 t = jj_consume_token(BICONDICIONAL);
        break;
      default:
        jj_la1[4] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
          ctlExpression = ctlExpression + " " + t.toString()+ " ";
      exp2 = ctlGrammar();
                ctlExpression = ctlExpression + " ) ";
          exp = new Expression("( "+exp1.getName() +" " + t.toString()+ " " + exp2.getName() + " )");
             exp.setExp1(exp1);
             exp.setExp2(exp2);
          if (t.toString().equals("^"))
           ep = ExpressionType.AND;
          else if (t.toString().toUpperCase().equals("V"))
                ep = ExpressionType.OR;
          else if (t.toString().equals("->"))
                ep = ExpressionType.IMP;
          else if (t.toString().equals("<->"))
                ep = ExpressionType.BIC;

             exp.setType(ep);
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("dualRelations");
    }
  }

  final public Expression ctlSpecifications() throws ParseException {
    trace_call("ctlSpecifications");
    try {
    Token t = new Token();
    ExpressionType ep = null;
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case AX:
        t = jj_consume_token(AX);
        break;
      case EX:
        t = jj_consume_token(EX);
        break;
      case AF:
        t = jj_consume_token(AF);
        break;
      case EF:
        t = jj_consume_token(EF);
        break;
      case AG:
        t = jj_consume_token(AG);
        break;
      case EG:
        t = jj_consume_token(EG);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    ctlExpression = ctlExpression + t.toString()+ " ";
    Expression exp = new Expression(t.toString()+ " ");
    if (t.toString().toUpperCase().equals("AX"))
        ep = ExpressionType.AX;
    else if (t.toString().toUpperCase().equals("EX"))
        ep = ExpressionType.EX;
    else if (t.toString().toUpperCase().equals("AF"))
        ep = ExpressionType.AF;
    else if (t.toString().toUpperCase().equals("EF"))
        ep = ExpressionType.EF;
    else if (t.toString().toUpperCase().equals("AG"))
        ep = ExpressionType.AG;
    else if (t.toString().toUpperCase().equals("EG"))
        ep = ExpressionType.EG;
    exp.setType(ep);
        {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("ctlSpecifications");
    }
  }

  final public Expression unionAux() throws ParseException {
    trace_call("unionAux");
    try {
  String tipo = "";
  Expression exp;
  ExpressionType ep = null;
      tipo = unionDec();
      exp = union();
   if (tipo.toUpperCase().equals("A"))
     ep = ExpressionType.AU;
   else if   (tipo.toUpperCase().equals("E"))
     ep = ExpressionType.EU;
   exp.setType(ep);
   //MEF.getInstance().getExpressions().add(exp);
   {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("unionAux");
    }
  }

  final public String unionDec() throws ParseException {
    trace_call("unionDec");
    try {
    Token t = new Token();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case E:
        t = jj_consume_token(E);
        break;
      case A:
        t = jj_consume_token(A);
        break;
      default:
        jj_la1[6] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    ctlExpression = ctlExpression + t.toString()+ " ";
        {if (true) return t.toString();}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("unionDec");
    }
  }

  final public Expression union() throws ParseException {
    trace_call("union");
    try {
  Token t = new Token();
  Expression exp;
  Expression exp1;
  Expression exp2;
      t = jj_consume_token(LBRACKET);
       ctlExpression = ctlExpression  + " [ ";
      exp1 = ctlGrammar();
      t = jj_consume_token(U);
       ctlExpression = ctlExpression +  " U ";
      exp2 = ctlGrammar();
      t = jj_consume_token(RBRACKET);
      ctlExpression = ctlExpression + " ] ";
            exp = new Expression(" [ " + exp1.getName() + " U " + exp2.getName() + " ] ");
            exp.setExp1(exp1);
            exp.setExp2(exp2);
                {if (true) return exp;}
    throw new Error("Missing return statement in function");
    } finally {
      trace_return("union");
    }
  }

/*
Expression logicalDefinitions():
{
  Token t = new Token();
  Expression exp; 
}
{	 (   t = <TRUE>     |     
	     t = <FALSE>	)
	 {
	   exp = new Expression(t.toString());
	   return exp;
	 }      
}
*/
  final public void satesDec() throws ParseException {
    trace_call("satesDec");
    try {
  Token t = new Token() ;
  State state = null;
      jj_consume_token(STATES);
      jj_consume_token(Lparentheses);
      label_2:
      while (true) {
        t = jj_consume_token(IDENTIFIER);
                                        state = new State(t.toString());
                                        MEF.getInstance().addState(state); // adiciona estado na estrutura MEF
                                        System.out.println("Estado "+t.toString()+" lido com sucesso e incluido na instacia da MEF");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[7] = jj_gen;
          break label_2;
        }
      }
      jj_consume_token(Rparentheses);
    } finally {
      trace_return("satesDec");
    }
  }

  final public void propertiesDec() throws ParseException {
    trace_call("propertiesDec");
    try {
        Token t = new Token() ;
        Property property = null;
      jj_consume_token(PROPERTIES);
      jj_consume_token(Lparentheses);
      label_3:
      while (true) {
        t = jj_consume_token(IDENTIFIER);
                                property = new Property(t.toString()); //
                                MEF.getInstance().addProperty(property); // adiciona estado na estrutura MEF
                                System.out.println("Propriedade "+t.toString()+" lido com sucesso e incluido na instacia da MEF");
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[8] = jj_gen;
          break label_3;
        }
      }
      jj_consume_token(Rparentheses);
    } finally {
      trace_return("propertiesDec");
    }
  }

  final public void behavioerDec() throws ParseException {
    trace_call("behavioerDec");
    try {
  Token t = new Token();
      jj_consume_token(DEFINE);
      jj_consume_token(LBRACKET);
      defineBody();
      jj_consume_token(RBRACKET);
    } finally {
      trace_return("behavioerDec");
    }
  }

  final public void defineBody() throws ParseException {
    trace_call("defineBody");
    try {
  Token t = new Token();
  State specified, analyzed;
  Property property = null;
      t = jj_consume_token(IDENTIFIER);
        analyzed = MEF.getInstance().getState(t.toString());
        MEF.getInstance().setFirstState(analyzed);
      jj_consume_token(Lparentheses);
      label_4:
      while (true) {
        t = jj_consume_token(IDENTIFIER);
         specified = MEF.getInstance().getState(t.toString());
         analyzed.addChild(specified);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[9] = jj_gen;
          break label_4;
        }
      }
      jj_consume_token(COLON);
      label_5:
      while (true) {
        t = jj_consume_token(IDENTIFIER);
         // código de insercao da propriedade nos estados 
         property = MEF.getInstance().getProperty(t.toString());
         analyzed.addValidProperties(property);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[10] = jj_gen;
          break label_5;
        }
      }
      jj_consume_token(Rparentheses);
      label_6:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case IDENTIFIER:
          ;
          break;
        default:
          jj_la1[11] = jj_gen;
          break label_6;
        }
        t = jj_consume_token(IDENTIFIER);
            analyzed = MEF.getInstance().getState(t.toString());
        jj_consume_token(Lparentheses);
        label_7:
        while (true) {
          t = jj_consume_token(IDENTIFIER);
         specified = MEF.getInstance().getState(t.toString());
         analyzed.addChild(specified);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[12] = jj_gen;
            break label_7;
          }
        }
        jj_consume_token(COLON);
        label_8:
        while (true) {
          t = jj_consume_token(IDENTIFIER);
         // código de insercao da propriedade nos estados 
         property = MEF.getInstance().getProperty(t.toString());
         analyzed.addValidProperties(property);
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case IDENTIFIER:
            ;
            break;
          default:
            jj_la1[13] = jj_gen;
            break label_8;
          }
        }
        jj_consume_token(Rparentheses);
      }
    } finally {
      trace_return("defineBody");
    }
  }

  /** Generated Token Manager. */
  public ssc5906JMCTokenManager token_source;
  SimpleCharStream jj_input_stream;
  /** Current token. */
  public Token token;
  /** Next token. */
  public Token jj_nt;
  private int jj_ntk;
  private int jj_gen;
  final private int[] jj_la1 = new int[14];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static {
      jj_la1_init_0();
      jj_la1_init_1();
   }
   private static void jj_la1_init_0() {
      jj_la1_0 = new int[] {0x8000000,0x6000000,0x61fb000,0x61fb000,0x0,0x1f8000,0x3000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_init_1() {
      jj_la1_1 = new int[] {0x0,0x200,0x202,0x212,0x1e0,0x0,0x0,0x200,0x200,0x200,0x200,0x200,0x200,0x200,};
   }

  /** Constructor with InputStream. */
  public ssc5906JMC(java.io.InputStream stream) {
     this(stream, null);
  }
  /** Constructor with InputStream and supplied encoding */
  public ssc5906JMC(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new SimpleCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new ssc5906JMCTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  /** Reinitialise. */
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  /** Constructor. */
  public ssc5906JMC(java.io.Reader stream) {
    jj_input_stream = new SimpleCharStream(stream, 1, 1);
    token_source = new ssc5906JMCTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  /** Constructor with generated Token Manager. */
  public ssc5906JMC(ssc5906JMCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  /** Reinitialise. */
  public void ReInit(ssc5906JMCTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 14; i++) jj_la1[i] = -1;
  }

  private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      trace_token(token, "");
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }


/** Get the next Token. */
  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
      trace_token(token, " (in getNextToken)");
    return token;
  }

/** Get the specific Token. */
  final public Token getToken(int index) {
    Token t = token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.List<int[]> jj_expentries = new java.util.ArrayList<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;

  /** Generate ParseException. */
  public ParseException generateParseException() {
    jj_expentries.clear();
    boolean[] la1tokens = new boolean[46];
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 14; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 46; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.add(jj_expentry);
      }
    }
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = jj_expentries.get(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  private int trace_indent = 0;
  private boolean trace_enabled = true;

/** Enable tracing. */
  final public void enable_tracing() {
    trace_enabled = true;
  }

/** Disable tracing. */
  final public void disable_tracing() {
    trace_enabled = false;
  }

  private void trace_call(String s) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Call:   " + s);
    }
    trace_indent = trace_indent + 2;
  }

  private void trace_return(String s) {
    trace_indent = trace_indent - 2;
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.println("Return: " + s);
    }
  }

  private void trace_token(Token t, String where) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Consumed token: <" + tokenImage[t.kind]);
      if (t.kind != 0 && !tokenImage[t.kind].equals("\"" + t.image + "\"")) {
        System.out.print(": \"" + t.image + "\"");
      }
      System.out.println(" at line " + t.beginLine + " column " + t.beginColumn + ">" + where);
    }
  }

  private void trace_scan(Token t1, int t2) {
    if (trace_enabled) {
      for (int i = 0; i < trace_indent; i++) { System.out.print(" "); }
      System.out.print("Visited token: <" + tokenImage[t1.kind]);
      if (t1.kind != 0 && !tokenImage[t1.kind].equals("\"" + t1.image + "\"")) {
        System.out.print(": \"" + t1.image + "\"");
      }
      System.out.println(" at line " + t1.beginLine + " column " + t1.beginColumn + ">; Expected token: <" + tokenImage[t2] + ">");
    }
  }

}
