/**
 * JavaCC template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 * Trabalho da Disciplina de Especificação Formal de Software.
 * Implementação - Model checker!
 */options{  	JDK_VERSION = "1.5";
	DEBUG_LOOKAHEAD = true;
  	IGNORE_CASE = true;   	static = true;}PARSER_BEGIN(ssc5906JMC)package br.parser;



import br.mef.*;
import java.util.*; 

public class ssc5906JMC{

static private final String Version = ("ssc5906JMC - icmcJMC - Java Model Checker \"Version 0.1\"  \n A Java implementation"); 
//static private MEF mef;
  public static void main(String args []) throws ParseException  {
	System.out.println(Version);
	String filename = " "; // file name to analyse
	ssc5906JMC parser;

	//Declaracao da MEF a ser instaciada e povoado por estados e propriedades
	

	
    
	if (args.length < 1)
	System.out.println("Sorry, you have to insert a parameter ...");
	// caso em que nenhum arquivo é passado como parâmetro

	else
	{
	//abrir o arquivo para leitura
 	filename = args[args.length-1];  
    System.out.println("Reading Specification from file " + filename + " . . .");
	try {  // cria AS
            parser = new ssc5906JMC(new java.io.FileInputStream(filename));
			parser.unitJavaMC(); // chamada do método que faz a análise ...
            System.out.println("--  Arquivo de parser valido --");
			 
			if (parser.token_source.foundLexError() > 0)
        	{
              System.out.println("Lexical Errors found");
        	}
        	else
        	{
			/* aqui devemos chamar métodos para processar a MEF e verificar propriedades ...*/
			System.out.println("#################Analise da MEF definida#################");
			ArrayList<State> state  = MEF.getInstance().getStates();

			System.out.println("O MEF definida contem: "+state.size()+" estados");
			System.out.println("O MEF definida contem: "+MEF.getInstance().getFirstState().getName()+" estados");
			MEF.getInstance().createMEF();
			
        	}
        } 
    catch (java.io.FileNotFoundException e)
    	{
        System.out.println("File " + filename + " not found.");
        return;
        }	}
	  } // end main()


static public String im(String s)
{
int k;
   k = s.lastIndexOf("\"");
   try {s = s.substring(1,k);}
   catch (StringIndexOutOfBoundsException e)
   {}
   return s;
}
  }PARSER_END(ssc5906JMC)

//####################################
// DECLARACAO DE ATOMOS DO AN. LEXICO
//####################################


TOKEN_MGR_DECLS :
{
static int countLexError = 0;

public int foundLexError()
{
   return countLexError;
}

}


/*caracteres a serem desprezados pelo compilador*///#################################################################
SKIP :
{
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

//#################################################################
//#################/*DEFINIÇÕES DE COMENTÁRIOS*/
SKIP :
{
  "/*" : multilinecomment
}
SKIP :
{
  "//" : singlelinecomment
}
<multilinecomment> SKIP:
{
   "*/" : DEFAULT
|  <~[]>
}

<singlelinecomment> SKIP:
{
   <["\n","\r"]> : DEFAULT
|   <~[]>
}


//#################################################################
//#################/*DEFINIÇÕES DE PALAVRAS RESERVADAS*/
TOKEN :{   <E: "E">
  | <A: "A">   
  | <U: "U">
  | <AX: "AX">
  | <EX: "EX">
  | <AF: "AF">
  | <EF: "EF">
  | <AG: "AG">
  | <EG: "EG">
|  <JMC: "JMC">| 	< STATES: "states">
| 	< PROPERTIES: "properties">
| 	< DEFINE: "def">
}

//#################################################################
//#################/*DEFINIÇÕES DE TODOS OS OPERADORES ESPECIAIS*/
TOKEN:{
   <COMMA:",">
  | < LBRACKET: "[">
  | < RBRACKET: "]">
  | < SEMICOLON: ";"> 
  | <COLON: ":">
  | <EQ: "=">
  | <Lparentheses : "(" >
  | <Rparentheses : ")" >
  | <RECEIVE: ":=" >

//#################################################################
//#################/*DEFINIÇÕES DOS OPERADORES ESPECIAIS CTL*/  
  | <NOT: "~" >
  | <AND: "^" >
  | <OR: "v">
  | <IMPLICATION: "->">  // if .. then
  | <BICONDICIONAL: "<->"> //if and only if ...
  
  
	}


//#################################################################
//#################/*DEFINIÇÃO DE IDENTIFICADORES EM PASCAL*/######
TOKEN:{
  <IDENTIFIER: <LETTER> (<LETTER> |<DIGIT>)*>
  | <LETTER:["a"-"z", "A"-"Z", "_"]>
  | <DIGIT:["0"-"9"]>
}


//#################################################################
//#################/*Tratador de erros léxicos*/######
SPECIAL_TOKEN :
{
<INVALID_LEXICAL: 
(~ ["a"-"z", "A"-"Z",
  "0"-"9",
  "\"",
  "\\",
  "/",
  "-",
  ";",
  ")",
  "(",
  "[",
  "]",
  ":",
  " ",
  "\t",
  "\n",
  "\r",
  "\f"
])+>
   {
    System.out.println("Line " + input_stream.getEndLine() + 
                           " - Invalid string found: " + image);
    countLexError++;
   }
|
   <INVALID_CONST: 
   "\"" (~ ["\n","\r","\""])* ["\n","\r"]>
   {
    System.out.println("Line " + input_stream.getEndLine() + 
                           " - String constant has a \\n: " + image);
    countLexError++;
   }
}



//########################################
// INICIO DA DECLARACAO DE DO AN. LEXICO
//########################################


void unitJavaMC():
{}{
  <JMC> // inicio
	icmcJavaModelCheckerUnit()
  <JMC> // fim default}


void icmcJavaModelCheckerUnit():
{}{
	(modelDec() ctlGrammar() (<COMMA> ctlGrammar())*)  // pode ser que nao tenhamos definicoes de propriedades
		}

void modelDec():
{  }
{ 	satesDec() propertiesDec() behavioerDec() // definicao de ordem de declaracoes do nosso modelo: estados, propriedades e comportamento	 }


void ctlGrammar():
{}{
  //<VERIFYING> // por eqto, a definicao de propriedades é apenas um texto verifying. Aqui será nosso trabalho
  // toDo, definir essa gramática seguindo normas de CTL
  <IDENTIFIER>   |				// definicao de propriedade atomica
  <Lparentheses> logicalRelations() <Rparentheses> |      //definicao de relacoes logicas parentisadas em CTL
  ctlSpecifications() ctlGrammar()   |
  unionDec() union()
}



void logicalRelations():
{}{
	negation() |
	dualRelations()	 }



void negation():
{
}
{
  <NOT> ctlGrammar()
}


void dualRelations():
{}{
  	ctlGrammar()
  	(
  	  <AND> | //conjunction
  	  <OR>  |  //disjunction
  	  <IMPLICATION> | //material implication - if  .. then
  	  <BICONDICIONAL> //Bicondicional - if and only if  	)
  	ctlGrammar()  	
}

void ctlSpecifications():
{}{   <AX> //em todos os próximos estados as propriedade e valida
  | <EX> //existe um próximo estado no qual a propriedade vale
  | <AF> //todas as execucoes fazem o caminho valer em algum lugar
  | <EF> //em algum lugar, é possível que aconteça
  | <AG> //propriedade sempre valida
  | <EG> //para um caminho, a partir de um estado, a prop. vale    }

void unionDec():
{}{
  (< E >|< A >)}

void union():
{}{
  <LBRACKET> ctlGrammar() <U> ctlGrammar() <RBRACKET>}


void satesDec(): 
{
  Token t = new Token() ;
  State state = null;  }{
   <STATES> 
    <Lparentheses>
   				( t = <IDENTIFIER>
			{			  		state = new State(t.toString()); // rafa
  					System.out.println("Estado "+t.toString()+" lido com sucesso e incluido na instacia da MEF");  					
  					MEF.getInstance().addState(state); // adiciona estado na estrutura MEF  					  								}
   				)+   				
   <Rparentheses>   
}

void propertiesDec(): // simples declaracao de propriedades
{}{
  <PROPERTIES>
  	<Lparentheses>  		
  			(<IDENTIFIER>)+
  	<Rparentheses>}

void behavioerDec():
{
  Token t = new Token();
}
{
 (t = <DEFINE>)
   <LBRACKET>  		defineBody() //exatamente uma especificacao de modelo
  <RBRACKET>}
void defineBody(): // especificação de um estado - próximos e propriedades
{
  Token t = new Token();
  State child, father;}{
 (t = <IDENTIFIER> )
 {  father = MEF.getInstance().getState(t.toString());
    MEF.getInstance().setFirstState(father); } 
  <Lparentheses>
      (t = <IDENTIFIER>)+
	{
	 child = MEF.getInstance().getState(t.toString());
	 father.addChild(child); 	}
       <COLON> (<IDENTIFIER>)+ <Rparentheses>

(     (t = <IDENTIFIER> )
	    {
	    father = MEF.getInstance().getState(t.toString());
		}


 <Lparentheses>

 (t = <IDENTIFIER>)+
{
	 child = MEF.getInstance().getState(t.toString());
	 father.addChild(child); }


  <COLON> (<IDENTIFIER>)+ <Rparentheses>)*
// montar o arquivo graphviz ...Vania !!!!!! Vai la!}


